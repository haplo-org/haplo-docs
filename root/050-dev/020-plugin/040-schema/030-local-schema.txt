title: Local schema
long_title: Plugin local schema dictionaries
--

Each plugin has a set of local schema dictionaries, one for each type of schema object. These allow you to write @A.Person@ instead of @ATTR['std:type:person']@, which is much easier to read.

The dictionary objects are made available to a plugin as arguments to the [node:dev/plugin/implement-plugin:anonymous function] generated by the platform to wrap your files are they're loaded.

These dictionary objects inherit from the appropraite [node:dev/plugin/schema/schema-global:SCHEMA dictionaries] so you can also use them for looking up API codes.

If you attempt to retrieve a local name or API code which isn't defined, you'll get an exeception at runtime. The plugin will check that any local names are defined in the [node:dev/plugin/schema/requirements-schema] file.

If you want to write functionality which is conditional on schema objects existing, use the API codes, and the JavaScript @in@ operator to check whether they're defined, for example @("std:type:person" in T)@.


h2. Local dictionaries

|Local dictionary|Contains|Inherits from|
|@T@|Types|[node:dev/plugin/schema/schema-global/type]|
|@A@|Attributes|[node:dev/plugin/schema/schema-global/attr]|
|@Q@|Qualifiers|[node:dev/plugin/schema/schema-global/qual]|
|@AA@|Aliased attributes|[node:dev/plugin/schema/schema-global/aliased-attr]|
|@Group@|Groups|[node:dev/plugin/schema/schema-global/group]|
|@Label@|Labels|[node:dev/plugin/schema/schema-global/label]|

Dictionaries are only generated if there is at least one entry of that type in the @requirements.schema@ file. @A@ is always available because it contains the implied @A.Type@, @A.Title@, @A.Parent@ entries which do not have to be declared in the requirements file.


h2. Example

If you include this line in your [node:dev/plugin/schema/requirements-schema] file:

<pre>
    type std:type:person as Person
</pre>

the @T@ local schema dictionary will be generated, and you can refer to the ref of the type as @T.Person@ in your code.