# Haplo Platform                                     http://haplo.org
# (c) Haplo Services Ltd 2006 - 2016    http://www.haplo-services.com
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


require 'erb'

class Documentation

  HTML_TEMPLATE_FILENAME = 'doc/web/template.html.erb'

  @@root = DocNode.new('')

  EXT_TO_NODE_CLASS = {
    'txt' => DocNodeTextile
  }

  # Load a file from disc, automatically determining the format
  def self.read_file_auto(filename, doc_root)
    raise "filename doesn't begin with doc_root" unless filename.index(doc_root+'/') == 0
    # Is it a ruby file?
    raise "Can't load ruby file at this stage" if filename =~ /\.rb\z/
    # Otherwise it's a documentation file
    path_elements = filename.slice(doc_root.length + 1, filename.length).split('/')
    last_element = path_elements.pop
    raise "file #{filename} doesn't have an extension" unless last_element =~ /\.(\w+)\z/
    file_extension = $1
    last_element.gsub!(/\.(\w+)\z/,'')
    # Remove any ordering numbers from the path
    path_elements.map! { |e| e.gsub(/\d+-/,'') }
    # Get any ordering from this element
    ordering = nil
    if last_element =~ /\A(\d+)-/
      ordering = $1.to_i
      last_element.gsub!(/\A\d+-/,'') # remove it
    end
    # Is this the file representing the directory?
    if last_element =~ /\A_(.+)\z/
      raise "Filenames starting with _ must be the same name as the parent dir" unless $1 == (path_elements.last || 'root')
      last_element = nil
      # Get the ordering from the parent?
      ordering = $1.to_i if filename =~ /\/(\d+)-[^\/]+\/_[^\/]+\.\w+\z/
    end
    path_elements << last_element if last_element != nil
    # Load the node!
    node = self.read_file(path_elements, filename, EXT_TO_NODE_CLASS[file_extension])
    node.ordering = ordering
    node.filename = filename
    node
  end

  # Read a file, and store it at a given path
  def self.read_file(path, filename, klass)
    node = klass.new(path.last)
    node = node.read_file(filename)
    insert_node(node, path)
    node
  end

  # Insert a node into the tree
  def self.insert_node(node, path)
    if path.empty?
      @@root = @@root.replace_with(node)
    else
      p2 = path.dup
      last_element = p2.pop
      scan = @@root
      p2.each do |name|
        scan.children[name] = DocNode.new(name, scan) unless scan.children.has_key? name
        scan = scan.children[name]
      end
      if scan.children.has_key? last_element
        scan.children[last_element].replace_with(node)
      else
        scan.children[last_element] = node
      end
      node.parent = scan
    end
    node
  end

  # Get root node
  def self.root_node
    @@root
  end

  # Do something after loading
  def self.after_load(&action)
    @@after_load << action
  end
  @@after_load = []
  def self.call_after_loads
    @@after_load.each do |action|
      action.call
    end
  end

  # Get a node given a path
  def self.get_node(path_as_string)
    path = path_as_string.gsub(/\A\//,'').split('/')
    scan = @@root
    path.each do |name|
      scan = scan.children[name]
      return nil if scan == nil
    end
    scan
  end

  # (Re)load the HTML template
  def self.load_html_template
    source = File.open(HTML_TEMPLATE_FILENAME) { |f| f.read }
    # Find all the IDs which are used by the template, so we can abort if they're generated by the headings
    @@template_ids = Hash.new
    source.scan(/id="([^"]+)"/) do
      @@template_ids[$1] = true
    end
    @@template = ERB.new(source)
  end

  def self.get_ids_used_in_template
    @@template_ids
  end

  # Get the HTML page for a node
  def self.make_html_for_node(node)
    rewrite_html(@@template.result(binding))
  end

  # Attempt to render all the nodes
  def self.check_all
    check_node_and_children(@@root)
  end
  def self.check_node_and_children(node)
    node.check_node
    begin
      make_html_for_node(node)
    rescue => e
      puts "\n\n************************\nERROR: Failed to generate page for #{node.url_path}\n    #{e.message}\n\n\n"
    end
    STDOUT.write('.'); STDOUT.flush
    node.children.each_value { |child| check_node_and_children(child) }
  end

  # Write the documentation for publishing on the web
  def self.publish_to(publish_dir)
    # Root node is special
    File.open("#{publish_dir}/index.html",'w') { |f| f.write make_html_for_node(@@root) }
    all_paths = [@@root.url_path]
    # Iterate through child nodes
    publish_node_children_to(@@root, publish_dir, all_paths)
    puts
    # Write sitemap file
    File.open("#{publish_dir}/sitemap.txt",'w') do |f|
      all_paths.each do |pathname|
        f.write "#{SITE_URL_BASE}#{pathname}\n"
      end
    end
    # Make 404 page
    node404 = DocNodeTextile.new('site/404')
    node404.read_file("#{publish_dir}/site/404.txt")
    File.unlink("#{publish_dir}/site/404.txt")
    File.open("#{publish_dir}/site/404.html", "w") do |file|
      file.write make_html_for_node(node404)
    end
  end

  def self.publish_node_children_to(node, pathname, all_paths)
    node.children.each_value do |child|
      STDOUT.write('.'); STDOUT.flush
      File.open("#{pathname}/#{child.name}.html",'w') { |f| f.write make_html_for_node(child) }
      all_paths << child.url_path
      unless child.children.empty?
        dir = "#{pathname}/#{child.name}"
        FileUtils.mkdir(dir)
        publish_node_children_to(child, dir, all_paths)
      end
    end
  end

end
